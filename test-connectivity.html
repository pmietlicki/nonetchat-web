<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test de ConnectivitÃ© PeerJS</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .success { background-color: #d4edda; border-color: #c3e6cb; }
        .error { background-color: #f8d7da; border-color: #f5c6cb; }
        .warning { background-color: #fff3cd; border-color: #ffeaa7; }
        .info { background-color: #d1ecf1; border-color: #bee5eb; }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #6c757d; cursor: not-allowed; }
        .log {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 10px;
            margin: 10px 0;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }
        .peer-info {
            background-color: #e9ecef;
            padding: 10px;
            margin: 10px 0;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ” Test de ConnectivitÃ© PeerJS</h1>
        
        <div class="test-section info">
            <h3>Configuration</h3>
            <label>URL du serveur de signalisation:</label>
            <input type="text" id="signalingUrl" value="wss://nonetchat-signaling.onrender.com" style="width: 100%; padding: 5px; margin: 5px 0;">
            <button onclick="startTest()">ğŸš€ DÃ©marrer le test</button>
            <button onclick="clearLogs()">ğŸ§¹ Effacer les logs</button>
        </div>

        <div class="test-section" id="peerStatus">
            <h3>ğŸ“¡ Statut du Peer</h3>
            <div id="peerInfo">Pas encore initialisÃ©</div>
        </div>

        <div class="test-section" id="connectionTest">
            <h3>ğŸ”— Test de Connexion</h3>
            <div id="connectionInfo">En attente...</div>
            <button onclick="testConnection()" id="testConnBtn" disabled>Tester la connexion</button>
        </div>

        <div class="test-section" id="stunTest">
            <h3>ğŸŒ Test des serveurs STUN</h3>
            <div id="stunInfo">En attente...</div>
            <button onclick="testStunServers()" id="testStunBtn">Tester STUN</button>
        </div>

        <div class="test-section">
            <h3>ğŸ“‹ Logs dÃ©taillÃ©s</h3>
            <div id="logs" class="log"></div>
        </div>
    </div>

    <script src="https://unpkg.com/peerjs@1.5.0/dist/peerjs.min.js"></script>
    <script>
        let peer = null;
        let testPeerId = null;

        function log(message, type = 'info') {
            const timestamp = new Date().toISOString();
            const logElement = document.getElementById('logs');
            const logEntry = `[${timestamp}] ${type.toUpperCase()}: ${message}\n`;
            logElement.textContent += logEntry;
            logElement.scrollTop = logElement.scrollHeight;
            console.log(logEntry);
        }

        function updatePeerStatus(status, className = 'info') {
            const element = document.getElementById('peerStatus');
            element.className = `test-section ${className}`;
            document.getElementById('peerInfo').innerHTML = status;
        }

        function updateConnectionStatus(status, className = 'info') {
            const element = document.getElementById('connectionTest');
            element.className = `test-section ${className}`;
            document.getElementById('connectionInfo').innerHTML = status;
        }

        function updateStunStatus(status, className = 'info') {
            const element = document.getElementById('stunTest');
            element.className = `test-section ${className}`;
            document.getElementById('stunInfo').innerHTML = status;
        }

        function clearLogs() {
            document.getElementById('logs').textContent = '';
        }

        async function startTest() {
            const signalingUrl = document.getElementById('signalingUrl').value;
            log(`DÃ©marrage du test avec: ${signalingUrl}`);
            
            if (peer) {
                peer.destroy();
            }

            testPeerId = 'test-' + Math.random().toString(36).substr(2, 9);
            log(`ID de test gÃ©nÃ©rÃ©: ${testPeerId}`);

            try {
                const url = new URL(signalingUrl);
                const peerOptions = {
                    host: url.hostname,
                    port: parseInt(url.port) || (url.protocol === 'wss:' ? 443 : 80),
                    path: url.pathname,
                    secure: url.protocol === 'wss:',
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' },
                            { urls: 'stun:stun2.l.google.com:19302' },
                            { urls: 'stun:stun3.l.google.com:19302' },
                            { urls: 'stun:stun4.l.google.com:19302' },
                            { urls: 'stun:stun.stunprotocol.org:3478' },
                            {
                                urls: "turn:openrelay.metered.ca:80",
                                username: "openrelayproject",
                                credential: "openrelayproject",
                            },
                            {
                                urls: "turn:openrelay.metered.ca:443",
                                username: "openrelayproject",
                                credential: "openrelayproject",
                            }
                        ],
                        iceCandidatePoolSize: 15,
                        iceTransportPolicy: 'all'
                    },
                    debug: 3
                };

                log(`Options PeerJS: ${JSON.stringify(peerOptions, null, 2)}`);
                updatePeerStatus('ğŸ”„ Connexion en cours...', 'warning');

                peer = new Peer(testPeerId, peerOptions);

                peer.on('open', (id) => {
                    log(`âœ… Peer connectÃ© avec l'ID: ${id}`);
                    updatePeerStatus(`âœ… ConnectÃ©<br>ID: <code>${id}</code><br>Serveur: ${url.hostname}:${url.port}`, 'success');
                    document.getElementById('testConnBtn').disabled = false;
                    discoverPeers();
                });

                peer.on('error', (err) => {
                    log(`âŒ Erreur PeerJS: ${err.type} - ${err.message}`, 'error');
                    updatePeerStatus(`âŒ Erreur: ${err.message}`, 'error');
                });

                peer.on('disconnected', () => {
                    log('âš ï¸ Peer dÃ©connectÃ© du serveur', 'warning');
                    updatePeerStatus('âš ï¸ DÃ©connectÃ© du serveur', 'warning');
                });

                peer.on('connection', (conn) => {
                    log(`ğŸ“ Connexion entrante de: ${conn.peer}`);
                    setupConnection(conn);
                });

            } catch (error) {
                log(`âŒ Erreur lors de l'initialisation: ${error.message}`, 'error');
                updatePeerStatus(`âŒ Erreur: ${error.message}`, 'error');
            }
        }

        function discoverPeers() {
            if (!peer || peer.destroyed) return;

            log('ğŸ” DÃ©couverte des pairs...');
            
            fetch(`${peer.socket._socket.url.replace('wss://', 'https://').replace('ws://', 'http://')}/peerjs/peers`)
                .then(response => response.json())
                .then(peerIds => {
                    log(`ğŸ“‹ Pairs dÃ©couverts: ${JSON.stringify(peerIds)}`);
                    updateConnectionStatus(`Pairs trouvÃ©s: ${peerIds.length}<br>IDs: ${peerIds.join(', ')}`, 
                        peerIds.length > 1 ? 'success' : 'warning');
                })
                .catch(error => {
                    log(`âŒ Erreur lors de la dÃ©couverte: ${error.message}`, 'error');
                    updateConnectionStatus(`âŒ Erreur de dÃ©couverte: ${error.message}`, 'error');
                });
        }

        function testConnection() {
            if (!peer || peer.destroyed) {
                log('âŒ Peer non initialisÃ©', 'error');
                return;
            }

            // CrÃ©er un second peer pour tester la connexion
            const testId2 = 'test-' + Math.random().toString(36).substr(2, 9);
            log(`ğŸ”— Test de connexion avec un second peer: ${testId2}`);
            
            const testPeer2 = new Peer(testId2, peer.options);
            
            testPeer2.on('open', () => {
                log(`âœ… Second peer connectÃ©: ${testId2}`);
                
                // Tenter de se connecter au premier peer
                const conn = testPeer2.connect(testPeerId);
                
                const timeout = setTimeout(() => {
                    log('â° Timeout de connexion (10s)', 'warning');
                    updateConnectionStatus('â° Timeout de connexion', 'warning');
                    testPeer2.destroy();
                }, 10000);
                
                conn.on('open', () => {
                    clearTimeout(timeout);
                    log('ğŸ‰ Connexion P2P Ã©tablie avec succÃ¨s!');
                    updateConnectionStatus('ğŸ‰ Connexion P2P rÃ©ussie!', 'success');
                    
                    // Test d'envoi de message
                    conn.send({ type: 'test', message: 'Hello from test!' });
                    
                    setTimeout(() => {
                        conn.close();
                        testPeer2.destroy();
                    }, 2000);
                });
                
                conn.on('error', (err) => {
                    clearTimeout(timeout);
                    log(`âŒ Erreur de connexion: ${err.message}`, 'error');
                    updateConnectionStatus(`âŒ Erreur: ${err.message}`, 'error');
                    testPeer2.destroy();
                });
            });
            
            testPeer2.on('error', (err) => {
                log(`âŒ Erreur du second peer: ${err.message}`, 'error');
                updateConnectionStatus(`âŒ Erreur: ${err.message}`, 'error');
            });
        }

        function setupConnection(conn) {
            conn.on('open', () => {
                log(`âœ… Connexion ouverte avec: ${conn.peer}`);
            });
            
            conn.on('data', (data) => {
                log(`ğŸ“¨ Message reÃ§u de ${conn.peer}: ${JSON.stringify(data)}`);
            });
            
            conn.on('close', () => {
                log(`ğŸ”Œ Connexion fermÃ©e avec: ${conn.peer}`);
            });
            
            conn.on('error', (err) => {
                log(`âŒ Erreur de connexion avec ${conn.peer}: ${err.message}`, 'error');
            });
        }

        async function testStunServers() {
            updateStunStatus('ğŸ”„ Test des serveurs STUN en cours...', 'warning');
            
            const stunServers = [
                'stun:stun.l.google.com:19302',
                'stun:stun1.l.google.com:19302',
                'stun:stun.stunprotocol.org:3478'
            ];
            
            let workingServers = 0;
            let results = [];
            
            for (const stunUrl of stunServers) {
                try {
                    log(`ğŸ§ª Test de ${stunUrl}...`);
                    
                    const pc = new RTCPeerConnection({
                        iceServers: [{ urls: stunUrl }]
                    });
                    
                    const result = await new Promise((resolve) => {
                        const timeout = setTimeout(() => resolve(false), 5000);
                        
                        pc.onicecandidate = (event) => {
                            if (event.candidate && event.candidate.type === 'srflx') {
                                clearTimeout(timeout);
                                resolve(true);
                            }
                        };
                        
                        pc.createDataChannel('test');
                        pc.createOffer().then(offer => pc.setLocalDescription(offer));
                    });
                    
                    pc.close();
                    
                    if (result) {
                        log(`âœ… ${stunUrl} fonctionne`);
                        workingServers++;
                        results.push(`âœ… ${stunUrl}`);
                    } else {
                        log(`âŒ ${stunUrl} ne rÃ©pond pas`, 'warning');
                        results.push(`âŒ ${stunUrl}`);
                    }
                    
                } catch (error) {
                    log(`âŒ Erreur avec ${stunUrl}: ${error.message}`, 'error');
                    results.push(`âŒ ${stunUrl} (erreur)`);
                }
            }
            
            const status = `Serveurs testÃ©s: ${stunServers.length}<br>Fonctionnels: ${workingServers}<br><br>${results.join('<br>')}`;
            updateStunStatus(status, workingServers > 0 ? 'success' : 'error');
        }

        // Auto-start test on page load
        window.onload = () => {
            log('ğŸš€ Page de test chargÃ©e');
        };
    </script>
</body>
</html>